# Procedural Generation System

**Status**: âœ… **IMPLEMENTED** - Procedural generation system is implemented with seed-based deterministic generation, building generation, and integration with player actions.

**Related Documentation**:
- [Map System](02-map-system.md) - Ring geometry and coordinate system
- [Zone System](09-zone-system.md) - Zones that guide procedural generation
- [Streaming System](07-streaming-system.md) - Chunk streaming for generated content
- [Database Schema](03-database-schema.md) - Chunk data storage
- [Test Coverage](tests/procedural-generation-test-coverage.md) - Test coverage analysis
- Server Implementation: `server/internal/procedural/`

## Table of Contents

- [Overview](#overview)
- [Core Principles](#core-principles)
- [Seed-Based Deterministic Generation](#seed-based-deterministic-generation)
- [City Grid Generation](#city-grid-generation)
- [Building Generation](#building-generation)
  - [Building Complexity Levels](#building-complexity-levels)
  - [Building Types](#building-types)
  - [Architectural Styles](#architectural-styles)
  - [Window Generation](#window-generation)
  - [Building Details](#building-details)
- [Window Lighting System](#window-lighting-system)
- [Window Silhouettes](#window-silhouettes)
- [Park and Agricultural Areas](#park-and-agricultural-areas)
- [Decorative Elements](#decorative-elements)
- [Performance Optimization](#performance-optimization)
- [Integration with Player Actions](#integration-with-player-actions)
- [Regeneration Strategy](#regeneration-strategy)
- [Implementation Phases](#implementation-phases)
- [Open Questions](#open-questions)
- [Future Considerations](#future-considerations)

## Overview

The procedural generation system creates the cityscape, buildings, parks, and decorative elements of EarthRing. It uses deterministic, seed-based algorithms to ensure consistent generation across all clients while allowing for variety and realistic city layouts.

**Implementation Status**: âœ… **SERVICE IMPLEMENTED** (Phase 1 + Phase 2 MVP)
- Python service implemented with FastAPI (`server/internal/procedural/main.py`)
- Go client implemented for service communication (`server/internal/procedural/client.go`)
- Seed generation utilities implemented (`server/internal/procedural/seeds.py`)
- **Station flare calculations**: âœ… **IMPLEMENTED** (`server/internal/procedural/stations.py`)
  - Variable-width chunks (400m base â†’ up to 25km at hub centers)
  - Variable-height chunks (5 base levels â†’ up to 15 levels at hub centers)
  - 12 pillar/elevator hubs positioned at regular intervals
  - Five-chunk plateau at each pillar seam (indices â€¦263998, 263999, 0, 1, 2â€¦) is clamped to maximum width before the cosine taper resumes, ensuring the seam renders perfectly flush
  - Cosine-based smooth transitions for the remainder of each flare zone
- **Per-Chunk Zones**: âœ… **IMPLEMENTED** - Each chunk includes one default restricted zone (1000m length Ã— 20m width) for maglev transit
- **Building Generation**: âœ… **IMPLEMENTED** (Phase 2 MVP)
  - Grid-based city generation (`server/internal/procedural/grid.py`)
  - Building generation with variability (`server/internal/procedural/buildings.py`)
  - Building subtypes (warehouse, factory, residence, agri_industrial, retail, mixed_use)
  - Varied footprints (10-80m width/depth based on type and subtype)
  - Discrete heights (5, 10, 15, or 20m within single 20m level)
  - Building generation in industrial, commercial, mixed-use, and agricultural zones
  - Window patterns with density varying by subtype
  - Building boundary validation (ensures buildings stay within zones)
  - Structure persistence (buildings stored and loaded with chunks)

**Key Characteristics:**
- **Deterministic**: Same seed always produces same result
- **Seed-based**: Uses hierarchical seed system for consistency
- **Zone-aware**: Adapts to player-defined zones (Phase 2)
- **Performance-optimized**: Uses LOD and caching strategies (Phase 2)
- **Player-aware**: Integrates with player-placed structures (Phase 2)
- **Cultural variation**: Buildings match Earth cultures below ring position (Phase 2)

## Core Principles

1. **Determinism**: Same inputs (seed, parameters) always produce same outputs
2. **Hierarchical Seeds**: Seeds derived from chunk â†’ building â†’ window levels
3. **Zone Integration**: Generation respects and enhances player-defined zones
4. **Performance Scaling**: Detail level adapts based on traffic and player attention
5. **Cultural Variation**: Building styles vary based on Earth position below ring
6. **Futuristic Aesthetic**: Modern, sustainable, space-age architecture
7. **Realistic Lighting**: Windows light/dim based on time of day and occupancy

## Per-Chunk Zone Generation

**Status**: âœ… **IMPLEMENTED** (Phase 1)

Each chunk generated by the procedural service includes one default restricted zone for maglev transit:

**Zone Specifications:**
- **Type**: Restricted (prevents building)
- **Dimensions**: 
  - Length: Full chunk length (1000 meters)
  - Width: Variable based on proximity to stations and station flare length:
    - **Base width**: 20 meters (Y: -10 to +10) for normal areas (outside station flares)
    - **Within station flare areas**, zones scale based on percentage of flare length:
      - **160m wide** (Y: -80 to +80): 20% of station length (centered on station, 0-10% of flare range from center)
      - **120m wide** (Y: -60 to +60): 40% of station length (0-20% of flare range from center)
      - **100m wide** (Y: -50 to +50): 60% of station length (0-30% of flare range from center)
      - **80m wide** (Y: -40 to +40): 80% of station length (0-40% of flare range from center)
    - Zones use variable-width polygons to smoothly transition between width zones
    - Station boundary extends to where the flare starts and ends (making stations much longer than wide)
- **Position**: Spans the full chunk length along the ring centerline
- **Hub Stations**: 12 pillar/elevator hubs at 30-degree intervals (every 22,000 km)
  - Pillar hubs have 50km flare length (25km each side)
  - Other station types (regional, local) will have different flare lengths
- **Generation**: Created by `generate_chunk_restricted_zone(floor, chunk_index)` in `generation.py`
- **Storage**: Zones are stored in the `zones` table and linked to chunks via `chunk_data.zone_ids`
- **Metadata**: Zones include metadata:
  ```json
  {
    "default_zone": "true",
    "chunk_index": "50000",
    "maglev_zone": "true"
  }
  ```

**Industrial Zones at Hub Platforms:**
- **Type**: Industrial (system zones)
- **Dimensions**:
  - Width: 80 meters on each side of the restricted zone
  - Length: Extends to the start of station flares (25km for pillar/elevator hubs)
  - **North industrial zone**: 80m wide strip on the negative Y side (north) of the restricted zone
  - **South industrial zone**: 80m wide strip on the positive Y side (south) of the restricted zone
- **Position**: Adjacent to restricted zones, following their variable width
- **Generation**: Created by `generate_chunk_industrial_zones(floor, chunk_index)` in `generation.py`
- **Storage**: Zones are stored with metadata distinguishing north/south sides:
  ```json
  {
    "default_zone": "true",
    "hub_zone": "true",
    "chunk_index": "50000",
    "side": "north"  // or "south"
  }
  ```
- **Coverage**: Industrial zones are generated within station flare areas (within flare_length/2 of hub centers)

**Implementation:**
- Zones are generated as GeoJSON Features alongside chunk geometry
- Zones are included in the chunk generation response in the `zones` array
- Zones are automatically stored in the database when chunks are stored
- Zones are reused when chunks are regenerated (checked by metadata matching)

**Hub Platform Industrial Zones:**
- Within station flare areas (within 25km of hub centers for pillar/elevator hubs), industrial zones are generated on either side of the restricted zone
- **North industrial zone**: 80m wide strip on the negative Y side (north side) of the restricted zone
- **South industrial zone**: 80m wide strip on the positive Y side (south side) of the restricted zone
- Industrial zones follow the variable width of the restricted zone, maintaining an 80m width at all points
- These zones extend from the hub center all the way to the start of the station flares (25km for pillar/elevator hubs)
- These zones are system zones (protected from player modifications) and marked with `metadata.hub_zone = true`

**Hub Platform Commercial Zones:**
- Within station flare areas, commercial zones are interspersed within industrial zones at chunk centers
- **North commercial zone**: 80m long (X axis) Ã— 80m wide (Y axis) on the north side of restricted zone
- **South commercial zone**: 80m long (X axis) Ã— 80m wide (Y axis) on the south side of restricted zone
- Commercial zones are positioned at the center of each chunk (40m on each side of chunk center)
- These zones create 80m Ã— 80m commercial areas breaking up the industrial zones every chunk (1km intervals)
- Commercial zones touch the restricted zone on their inner edge and extend 80m outward into the industrial zone
- These zones are system zones (protected from player modifications) and marked with `metadata.hub_zone = true`
- Metadata includes `side: "north"` or `side: "south"` to distinguish zones

**Mixed-Use Zones at Hub Platforms:**
- Within station flare areas, mixed-use zones are generated outside the industrial/commercial bands
- **North mixed-use zone**: 80m wide strip on the negative Y side, outside industrial zones
- **South mixed-use zone**: 80m wide strip on the positive Y side, outside industrial zones
- Mixed-use zones extend from the outer edge of industrial zones outward by 80m
- These zones are system zones (protected from player modifications) and marked with `metadata.hub_zone = true`
- Metadata includes `side: "north"` or `side: "south"` to distinguish zones

**Agricultural Zones Between Stations:**
- **Type**: Agricultural (NOT system zones - can be dezoned/replaced by players)
- **Distribution**: Generated in free space between stations (outside station flare areas)
- **Dimensions**:
  - **North agricultural zone**: From north edge of restricted zone to north edge of chunk
  - **South agricultural zone**: From south edge of restricted zone to south edge of chunk
  - Length: Full chunk length (1000 meters)
  - Width: Variable based on chunk width and restricted zone width (fills all available space)
- **Position**: Fills free space on both sides of restricted zone, following variable chunk width
- **Generation**: Created by `generate_chunk_agricultural_zones(floor, chunk_index)` in `generation.py`
- **Storage**: Zones are stored with `is_system_zone = false` and metadata distinguishing north/south sides:
  ```json
  {
    "default_zone": "true",
    "chunk_index": "50000",
    "side": "north"  // or "south"
  }
  ```
- **Player Modifications**: 
  - `is_system_zone = false` - These zones are NOT protected from player modifications
  - Players can dezone agricultural zones directly (even if unowned) - special exception in dezone logic
  - Players can replace agricultural zones by creating overlapping zones (new zones win since agricultural zones are not system zones)
  - Agricultural zones follow the same conflict resolution as player zones (new zones subtract from agricultural zones)
  - Agricultural zones can be modified or removed by players
- **Coverage**: Agricultural zones are generated outside station flare areas (where there's free space between stations)

**Functions:**
- `generate_chunk_restricted_zone(floor: int, chunk_index: int) -> dict`
  - Generates a restricted zone polygon spanning the chunk with variable width
  - Uses `calculate_restricted_zone_width(x_position)` to determine width at each point
  - Samples width every 50m along the chunk to create smooth transitions
  - Returns GeoJSON Feature format with geometry and metadata
  - Called by `generate_chunk()` for each chunk

- `generate_chunk_industrial_zones(floor: int, chunk_index: int) -> list`
  - Generates two 80m-wide industrial zones on either side of the restricted zone
  - Only generated within station flare areas
  - Returns list of two GeoJSON Feature zones (north and south)
  - Called by `generate_chunk()` for chunks within station flare areas

- `generate_chunk_commercial_zones(floor: int, chunk_index: int) -> list`
  - Generates two 80m Ã— 80m commercial zones at chunk centers
  - Only generated within station flare areas (where industrial zones exist)
  - Creates commercial zones interspersed within industrial zones
  - Returns list of two GeoJSON Feature zones (north and south)
  - Called by `generate_chunk()` for chunks within station flare areas

- `generate_chunk_mixed_use_zones(floor: int, chunk_index: int) -> list`
  - Generates two 80m-wide mixed-use zones outside the industrial/commercial bands
  - Only generated within station flare areas
  - Returns list of two GeoJSON Feature zones (north and south)
  - Called by `generate_chunk()` for chunks within station flare areas

- `generate_chunk_agricultural_zones(floor: int, chunk_index: int) -> list`
  - Generates two agricultural zones on either side of the restricted zone
  - Only generated outside station flare areas (free space between stations)
  - Fills space from restricted zone edges to chunk edges
  - Uses variable chunk width to follow ring curvature
  - Returns list of two GeoJSON Feature zones (north and south)
  - Zones are NOT system zones (`is_system_zone = false`) - can be dezoned/replaced by players
  - Called by `generate_chunk()` for chunks outside station flare areas

**Function:** `calculate_restricted_zone_width(x_position: float) -> float`
- Calculates the half-width of the restricted zone at a given X position
- Accounts for ring wrapping when calculating distance to nearest hub station
- Returns half-width in meters (actual width = return_value * 2)

## Seed-Based Deterministic Generation

**Status**: âœ… **IMPLEMENTED** (Phase 1)

### Seed Hierarchy

Seeds are derived hierarchically to ensure consistency:

```
World Seed (global constant)
  â””â”€ Chunk Seed = hash(floor_number, chunk_index, world_seed)
      â””â”€ Building Seed = hash(chunk_seed, building_cell_x, building_cell_y)
          â””â”€ Window Seed = hash(building_seed, window_x, window_y)
              â””â”€ Decoration Seed = hash(window_seed, decoration_index)
```

### Seed Generation Functions

**Chunk Seed:**
```python
def get_chunk_seed(floor: int, chunk_index: int, world_seed: int) -> int:
    """Generate deterministic seed for a chunk."""
    return hash((floor, chunk_index, world_seed)) % (2**31)
```

**Building Seed:**
```python
def get_building_seed(chunk_seed: int, cell_x: int, cell_y: int) -> int:
    """Generate deterministic seed for a building cell."""
    return hash((chunk_seed, cell_x, cell_y)) % (2**31)
```

**Window Seed:**
```python
def get_window_seed(building_seed: int, window_x: int, window_y: int) -> int:
    """Generate deterministic seed for a window."""
    return hash((building_seed, window_x, window_y)) % (2**31)
```

### Deterministic Random Number Generation

All random operations use seeded random number generators:

```python
import random

def seeded_random(seed: int):
    """Create deterministic random number generator."""
    rng = random.Random(seed)
    return rng
```

**Critical Rule**: Never use true randomness (`random.random()` without seed). Always use seeded RNGs.

## City Grid Generation

**Status**: âœ… **IMPLEMENTED** (Phase 2 MVP)

### Grid-Based Layout

**Cell Size**: 50m Ã— 50m (configurable)

**Algorithm:**

```
1. Input: Zone polygon, zone type, zone importance
2. Create grid overlay (50m cells) within zone bounds
3. For each cell:
   a. Determine cell type based on:
      - Distance from zone edge
      - Zone type (residential/commercial/industrial)
      - Zone importance
      - Noise function for variation
   b. Assign cell type:
      - Road/Plaza (near edges, high traffic areas)
      - Building (center areas, based on density)
      - Park (residential zones, based on noise)
      - Agricultural (designated agricultural zones)
4. Connect cells with transportation network
5. Add decorative elements based on cell type
```

### Cell Type Distribution

**Residential Zones:**
- Buildings: 70%
- Parks: 20%
- Plazas: 5%
- Roads: 5%

**Commercial Zones:**
- Buildings: 80%
- Plazas: 15%
- Parks: 3%
- Roads: 2%

**Industrial Zones:**
- Buildings: 85%
- Roads: 10%
- Plazas: 3%
- Parks: 2%

**Agricultural Zones:**
- Agricultural plots: 70%
- Storage buildings: 15%
- Roads: 10%
- Support structures: 5%

### Grid Generation Implementation

```python
def generate_city_grid(zone_polygon, zone_type, zone_importance, chunk_seed):
    """Generate city grid within zone."""
    rng = seeded_random(chunk_seed)
    
    # Create 50m grid cells
    cells = create_grid_cells(zone_polygon, cell_size=50)
    
    # Determine distribution based on zone type
    distribution = get_zone_distribution(zone_type)
    
    # Assign cell types
    for cell in cells:
        # Use noise for organic variation
        noise_value = perlin_noise(cell.x, cell.y, chunk_seed)
        
        # Determine if edge cell
        is_edge = is_near_zone_edge(cell, zone_polygon)
        
        if is_edge:
            cell.type = "road" if rng.random() < 0.7 else "plaza"
        else:
            # Use distribution + noise for variation
            cell.type = select_cell_type(distribution, noise_value, rng)
    
    return cells
```

## Building Generation

**Status**: âœ… **IMPLEMENTED** (Phase 2 MVP)

### Phase 2 MVP Implementation

**Current Features:**
- Grid-based city generation with 50m Ã— 50m cells
- Basic rectangular building shapes with varied footprints and heights
- Building subtypes for variety (warehouses, factories, residences, agri-industrial, retail)
- Simple window grid patterns (front and back facades) with density varying by subtype
- Building generation in industrial, commercial, mixed-use, and agricultural zones
- Building boundary validation (ensures all corners stay within zone boundaries)
- Structure persistence (buildings stored and loaded with chunks)
- Deterministic seed-based generation

**Building Heights:**
- All buildings use a 4m floor system (1m logistics floor + 3m living space per floor)
- Building heights: 4m, 5m, 8m, 10m, 12m, 15m, 16m, or 20m (1 to 5 floors)
- Heights are chosen based on building type and subtype
- Each level is 20m floor-to-ceiling, allowing buildings up to 20m tall within a single level

**Building Dimensions by Zone Type (Enhanced Shape Weights - Geometry Version 7):**
- **Industrial**:
  - **Warehouses** (60% probability): 40-80m width/depth (wide and long), mostly short (5-10m height, 80% of the time), some medium (12m, 20%)
  - **Factories** (40% probability): 30-65m width/depth (wide and long), mostly short/medium (5-12m height, 70%), some taller (16-20m, 30%)
- **Commercial**:
  - **Retail** (100% in commercial zones): 15-35m width/depth, **exactly 20m height** (all are 5-story office towers)
- **Residential**:
  - **Apartment/Campus buildings** (60% probability): 20-40m width/depth (larger), 12-20m height (3-5 stories)
  - **Houses** (40% probability): 10-18m width/depth (smaller), 8-12m height (2-3 stories)
- **Mixed-Use**:
  - Can generate any building type: residential (apartment/house), commercial (retail 20m), or industrial (warehouse/factory)
- **Agricultural**:
  - Buildings are **clustered** within 100m radius
  - Each cluster contains: 1 house (10-18m footprint, 8-12m tall), 1 barn (12-25m footprint, 5-10m tall), 1-2 small industrial (15-30m footprint, 5-10m tall)
  - **All agricultural zones along ring segments** generate agricultural structures (not just clustered buildings)
  - Isolated buildings not in clusters also get agricultural building types: 40% house, 30% barn, 30% small industrial (warehouse)
- **Park**:
  - **Park structures**: 5-15m width/depth (small), 4-8m height (mostly 1-2 stories)

**Building Subtypes:**
- Buildings include a `building_subtype` field for variety:
  - Industrial: `warehouse` or `factory`
  - Agricultural: `house`, `barn`, `warehouse` (small industrial), or `agri_industrial`
  - Commercial: `retail` (always, for commercial zones)
  - Mixed-use: Can be any residential, commercial, or industrial subtype
  - Residential: `apartment`, `campus`, or `house`

**Window Generation:**
- Windows on all four facades (front, back, left, right)
- Window size: 2.5m wide Ã— variable height based on type
- Window spacing: 0.5m
- Density and type preferences vary by building subtype:
  - **Warehouses**: ~10% density (very few windows), minimal window types
  - **Factories**: ~20% density (few windows), mostly standard windows
  - **Barns/Agri-industrial**: ~20% density (limited windows), mostly standard windows
  - **Retail** (office towers): ~75% density (high window coverage), **mostly full-height windows (85% chance per floor)**
  - **Apartments/Campuses/Houses**: 60-70% density (good window coverage), **mostly standard windows (85% chance per floor)**
  - **Park structures**: ~40% density (moderate windows), mostly standard windows
- Window type distribution per floor:
  - Commercial: 85% full-height, 15% standard, 10% ceiling
  - Residential/Others: 20% full-height, 85% standard, 25% ceiling
  - Industrial/Warehouse: 10% full-height, 30% standard, 10% ceiling
- Occasional missing windows for variation (10% chance)

**New Window System (4m Floor Height):**
- Standard floor height changed from 5m to 4m (1m logistics floor, 3m living space)
- Three window types per floor:
  - **Full-height windows**: 1.0m to 4.0m (3m tall), do not overlap logistics floor
  - **Standard windows**: 2.0m to 3.0m (1m tall)
  - **Ceiling windows**: 3.25m to 3.75m (0.5m tall)
- Pattern repeats for each floor (buildings can be 1-5 floors, 4m, 8m, 12m, 16m, or 20m tall)
- **Windows on all four facades** (front, back, left, right)
- Window type preferences:
  - Commercial buildings: Mostly full-height windows (85% chance per floor)
  - Residential buildings: Mostly standard windows (85% chance per floor)
  - Industrial buildings: Minimal windows with mixed types

**Door Generation:**
- âœ… **IMPLEMENTED** - Buildings include main and secondary doors
- Main door always on the facade facing r=0 (center of ring)
- Door specifications:
  - Standard door: 90cm wide Ã— 210cm tall (0.9m Ã— 2.1m)
  - Door bottom positioned at 1m above building base (just above logistics sub-floor)
  - Doors positioned to avoid overlapping windows and corner trim
- Door placement by building type:
  - **Commercial (office towers)**: Doors on all four sides (front, back, left, right)
  - **Apartment/Campus buildings**: Multiple doors (2-3 additional doors on various facades)
  - **Houses**: Fewer doors (main door, 20% chance for one secondary door)
  - **Industrial buildings (warehouses, factories)**: REQUIRE at least 1 standard door on BOTH north and south sides (front and back facades)
  - **Legacy residence subtype**: 40% chance for secondary door
  - **Factories**: 30% chance for secondary door
- Doors avoid overlapping windows with collision detection

**Garage Door Generation:**
- âœ… **IMPLEMENTED** - Industrial and agricultural buildings can have garage doors
- Garage door specifications:
  - Standard garage door: 3.0m wide Ã— up to 3.5m tall (or 60% of building height)
  - Garage doors positioned at building base (ground level)
- Garage door placement:
  - **Warehouses**: REQUIRE at least 1 garage door on BOTH front and back facades. Each facade gets 1-4 garage doors side-by-side (1 is minimum, 50% chance for 2, 35% for 3, 15% for 4)
  - **Factories**: REQUIRE at least 1 garage door on BOTH front and back facades. Each facade gets 1-3 garage doors
  - **Barns**: 70% chance, 1-2 garage doors on one facade
  - **Agri-industrial**: 70% chance, 1-2 garage doors on one facade
- Garage doors placed on front or back facades (larger facades)
- Multiple garage doors are positioned **side-by-side** with 0.5m spacing between them
- **Utility doors**: Each garage door has a utility door (90cm Ã— 210cm) placed immediately beside it (30cm spacing), either to the right or left depending on available space

**Hub-Specific Color Palettes:**
- âœ… **IMPLEMENTED** - Buildings use hub-specific color palettes based on their location
- Color palettes are stored in `server/config/hub-color-palettes.json`
- Each of the 12 pillar hubs has unique color schemes for each zone type:
  - Industrial: Dark, utilitarian colors (metals, concrete, industrial materials)
  - Commercial: Vibrant, welcoming colors (bright whites, colors, glass)
  - Residential: Warm, homely colors (earth tones, wood, soft colors)
  - Parks: Natural, green colors (greens, earth tones, natural materials)
  - Agricultural: Earthy, functional colors (browns, greens, natural materials)
- Color components: foundation, walls, roofs, windows_doors, trim
- Colors are applied via shader-based rendering (foundations, walls, windows, doors, trim rendered procedurally)
- Colors are loaded by the procedural service during building generation
- Hub name is determined from chunk position using `stations.get_hub_name_for_position()`
- Color palettes are loaded via `color_palettes.get_hub_colors()` which handles hub name mapping
- API endpoint: `GET /api/config/hub-colors` serves the color palettes to clients (public, no auth required)
- Mixed-use zones use Commercial palette colors (automatically mapped)
- Zone type normalization handles variations ("mixed-use", "mixed_use", "Mixed-Use" all map correctly)
- Colors are stored in building properties and passed through to client for rendering
- Client-side shader uniforms receive color values and apply them to building materials

**Building Rendering:**
- âœ… **Shader-based rendering** - Windows, doors, foundations, and trim are rendered procedurally in shaders
- Significantly reduces draw calls and eliminates z-fighting issues
- Opaque materials for all building components
- Performance optimized with material caching and geometry reuse
- **Corner trim**: Variable width between 10cm and 50cm per building (randomly generated per building)
- **Window opacity**: Windows use 65% opacity with slight reflectivity (1.2x brightness multiplier) for realistic glass appearance
- **Door types**: Supports regular doors, utility doors (beside garage doors), and garage doors - all rendered via shader

**Files:**
- `server/internal/procedural/grid.py` - Grid-based city layout generation
- `server/internal/procedural/buildings.py` - Building generation and window patterns (includes color palette integration)
- `server/internal/procedural/generation.py` - Integration with zone system and structure generation (determines hub name for chunks)
- `server/internal/procedural/color_palettes.py` - Color palette loading and management from JSON file
- `server/internal/procedural/stations.py` - Hub name lookup function `get_hub_name_for_position()`
- `server/config/hub-color-palettes.json` - Hub-specific color palette definitions (12 hubs Ã— 5 zone types Ã— 5 components)
- `server/internal/api/config_handlers.go` - API endpoint handler for serving color palettes
- `server/internal/api/config_routes.go` - Route registration for `/api/config/hub-colors`
- `server/cmd/earthring-server/main.go` - Server main entry point (registers config routes)
- `client-web/src/structures/structure-manager.js` - Client-side building rendering with shader-based details and color application

**Structure Storage:**
- Structures are stored in the `structures` table when chunks are saved
- Structure IDs are stored in `chunk_data.structure_ids`
- Structures are loaded when chunks are loaded from the database
- Structures include dimensions, windows, doors, garage_doors, building_subtype, and properties in `model_data` JSONB field
- **Door persistence**: Doors and garage_doors are saved to `model_data` when structures are stored and extracted when loaded from database
- Structures are reconstructed from database with all door/garage door data included in chunk responses via WebSocket
- Client-side extraction ensures doors are available at top level regardless of source (fresh chunks or database-loaded)

### Building Complexity Levels

**Decision**: Buildings use adaptive complexity based on traffic and player attention, similar to NPC system.

**Complexity Levels:**

1. **Abstract Mass** (Low Detail)
   - Simple box shape
   - Basic window grid (no individual windows)
   - No lighting
   - No silhouettes
   - Used for: Low-traffic areas, distant buildings, unvisited areas

2. **Standard Detail** (Medium Detail)
   - Defined building shape
   - Individual windows (grid pattern)
   - Basic lighting (on/off per window)
   - No silhouettes
   - Used for: Normal traffic areas, standard buildings

3. **High Detail** (Full Detail)
   - Complex building shape
   - Individual windows with variation
   - Dynamic lighting (dimming, color variation)
   - Silhouettes in lit windows
   - Architectural details (balconies, external structures)
   - Used for: High-traffic areas, frequently visited buildings, player attention

**Complexity Assignment:**

```python
def get_building_complexity(building_id, traffic_data, player_attention_data):
    """Determine building complexity level."""
    # Base complexity from traffic
    traffic_score = get_traffic_score(building_id, traffic_data)
    
    # Boost from player attention
    attention_score = get_attention_score(building_id, player_attention_data)
    
    # Combined score
    total_score = traffic_score + (attention_score * 2)  # Attention weighted higher
    
    if total_score > 0.7:
        return "high_detail"
    elif total_score > 0.3:
        return "standard_detail"
    else:
        return "abstract_mass"
```

**Player Attention Tracking:**
- Track how often players look at/interact with buildings
- Buildings gain "attention points" when viewed/interacted
- Attention decays over time (similar to NPC favoritism)
- High-attention buildings get upgraded to high detail

### Building Types

**Residential Buildings:**
- **Apartment/Campus buildings** (60% probability): Larger footprint (20-40m), taller (12-20m, 3-5 stories)
  - Multiple doors (2-3 additional doors for accessibility)
  - Mostly standard windows (85% chance per floor)
  - Windows on all four facades
- **Houses** (40% probability): Smaller footprint (10-18m), shorter (8-12m, 2-3 stories)
  - Fewer doors (main door, 20% chance for one secondary door)
  - Mostly standard windows (85% chance per floor)
  - Windows on all four facades

**Commercial Buildings:**
- **Retail**: Footprint (15-35m), **exactly 20m tall** (all are 5-story office towers)
  - Office towers with floor-to-ceiling windows (85% chance per floor)
  - Doors on all four sides for accessibility
  - Glass-heavy aesthetic with large facades

**Industrial Buildings:**
- **Warehouse**: Very large footprint (35-70m), low height (5-10m)
  - Single-story storage facilities
  - Minimal windows (~15% density)
- **Factory**: Large footprint (25-55m), medium height (10-15m)
  - Multi-story manufacturing
  - Some windows (~30% density)

**Agricultural Buildings:**
- **Clustering System**: Buildings within 100m radius are grouped into clusters
  - Each cluster forms a farming community with: 1 house (farmhouse), 1 barn, and 1-2 small industrial buildings
- **House**: Small footprint (10-18m), low-medium height (8-12m, 2-3 stories)
  - Farmhouses with good window coverage
- **Barn**: Medium footprint (12-25m), low height (5-10m)
  - Small warehouse/barn structures
  - Limited windows (~20% density)
  - Garage doors (1-2 doors, 70% chance)
- **Small Industrial**: Medium footprint (15-30m), low height (5-10m)
  - Small processing/storage buildings
  - Limited windows (~20% density)

**Special Buildings:**
- Transportation hubs (unique shape, large)
- Public facilities (hospitals, schools, etc.)
- Agricultural storage (large, functional)

### Architectural Styles

**Decision**: Building styles match Earth cultures below ring position.

**Cultural Regions:**

1. **East Asian** (China, Japan, Korea, etc.)
   - Clean lines, minimalist
   - Vertical emphasis
   - Integrated green spaces
   - Futuristic but traditional elements

2. **European** (Western Europe)
   - Mixed old and new
   - Public spaces emphasis
   - Sustainable design
   - Historical references

3. **North American** (USA, Canada)
   - Bold, modern
   - Large scale
   - Technology integration
   - Commercial emphasis

4. **South American** (Brazil, Argentina, etc.)
   - Colorful, vibrant
   - Community spaces
   - Tropical adaptations
   - Cultural fusion

5. **Middle Eastern** (Gulf states, etc.)
   - Grand scale
   - Geometric patterns
   - Luxury materials
   - Modern Islamic architecture

6. **African** (Various regions)
   - Community-focused
   - Sustainable materials
   - Cultural patterns
   - Modern adaptations

7. **South Asian** (India, Pakistan, etc.)
   - Dense, vertical
   - Color and pattern
   - Mixed-use emphasis
   - Traditional + modern

8. **Oceanic** (Australia, Pacific Islands)
   - Open, airy
   - Natural integration
   - Sustainable focus
   - Island adaptations

**Style Selection:**

```python
def get_cultural_style(ring_position_x):
    """Determine cultural style based on Earth position below ring."""
    # Ring position X corresponds to longitude on Earth
    # X=0 is Prime Meridian (Gulf of Guinea)
    
    # Map ring position to Earth longitude
    earth_longitude = (ring_position_x / 264000) * 360 - 180
    
    # Determine cultural region
    if -10 <= earth_longitude <= 50:  # Europe, Middle East
        if 30 <= earth_longitude <= 50:
            return "middle_eastern"
        else:
            return "european"
    elif 50 <= earth_longitude <= 150:  # Asia
        if 100 <= earth_longitude <= 150:
            return "east_asian"
        else:
            return "south_asian"
    elif 150 <= earth_longitude <= 180 or -180 <= earth_longitude <= -120:  # Pacific
        return "oceanic"
    elif -120 <= earth_longitude <= -50:  # Americas
        if -100 <= earth_longitude <= -50:
            return "south_american"
        else:
            return "north_american"
    elif -50 <= earth_longitude <= 50:  # Africa
        return "african"
    else:
        return "default"  # Fallback
```

**Style Application:**

```python
def apply_cultural_style(building, style):
    """Apply cultural architectural style to building."""
    style_params = CULTURAL_STYLES[style]
    
    # Adjust building parameters
    building.window_pattern = style_params.window_pattern
    building.color_scheme = style_params.color_scheme
    building.roof_style = style_params.roof_style
    building.decorative_elements = style_params.decorative_elements
    building.materials = style_params.materials
```

### Window Generation

**Decision**: Lots of windows, futuristic glass buildings. Fake transparency and fake lighting acceptable. Not every window needs dynamic light casting shadows.

**Window Density:**
- **High**: 60-80% of facade covered in windows (glass buildings)
- **Medium**: 40-60% coverage (mixed)
- **Low**: 20-40% coverage (industrial, some residential)

**Window Patterns:**

1. **Grid Pattern** (Most common)
   - Regular rows and columns
   - Window size: 2-3m wide Ã— 2-3m tall
   - Spacing: 0.5-1m between windows
   - Variation: Occasional missing windows, different sizes

2. **Strip Windows** (Horizontal bands)
   - Continuous horizontal strips
   - 1-2m tall strips
   - Spacing between strips: 1-2m

3. **Vertical Strips** (Less common)
   - Vertical window columns
   - 1-2m wide columns
   - Spacing: 1-2m

4. **Curved/Organic** (Futuristic)
   - Curved window patterns
   - Organic shapes
   - Used for special buildings

**Window Generation Algorithm:**

```python
def generate_windows(building, building_seed, complexity_level):
    """Generate windows for building facade."""
    rng = seeded_random(building_seed)
    
    # Determine window density based on building type
    if building.type == "commercial":
        density = rng.uniform(0.6, 0.8)  # High density
    elif building.type == "residential":
        density = rng.uniform(0.4, 0.6)  # Medium density
    else:
        density = rng.uniform(0.2, 0.4)  # Low density
    
    # Select pattern
    pattern = select_window_pattern(building.type, rng)
    
    # Generate window grid
    windows = []
    facade_width = building.width
    facade_height = building.height
    
    if pattern == "grid":
        windows = generate_grid_windows(
            facade_width, facade_height, density, rng
        )
    elif pattern == "strip_horizontal":
        windows = generate_strip_windows_horizontal(
            facade_width, facade_height, density, rng
        )
    # ... other patterns
    
    # Add variation
    for window in windows:
        # Size variation
        window.width *= rng.uniform(0.9, 1.1)
        window.height *= rng.uniform(0.9, 1.1)
        
        # Occasional missing windows (5% chance)
        if rng.random() < 0.05:
            window.exists = False
    
    return windows
```

**Fake Transparency:**
- Use texture mapping for glass appearance
- Reflect environment (sky, nearby buildings)
- No actual transparency calculations needed
- Performance-friendly

**Fake Lighting:**
- Pre-calculated light maps
- Window brightness based on time of day
- No dynamic shadow casting per window
- Simple brightness values (0.0 to 1.0)

### Building Details

**Futuristic Elements:**

1. **Solar Panels**
   - On roofs (flat roofs)
   - Some facades (south-facing)
   - Density based on building type

2. **Vertical Gardens**
   - On some facades (residential, commercial)
   - Integrated into building design
   - 10-20% of buildings have vertical gardens

3. **Holographic Signage**
   - Commercial buildings
   - Futuristic displays
   - Animated (simple animations)

4. **Landing Pads**
   - Top of tall buildings (20% of buildings >10 floors)
   - For drones, small vehicles
   - Safety railings, lighting

5. **External Structures**
   - Pipes, vents, conduits
   - Industrial buildings
   - Some residential (utilities)

6. **Balconies**
   - Residential buildings
   - 30-50% of residential buildings
   - Vary in size and style

**Detail Generation:**

```python
def generate_building_details(building, building_seed, complexity_level):
    """Generate architectural details for building."""
    rng = seeded_random(building_seed)
    details = []
    
    # Solar panels (roof)
    if building.has_flat_roof and rng.random() < 0.6:
        details.append({
            "type": "solar_panel",
            "location": "roof",
            "coverage": rng.uniform(0.3, 0.7)
        })
    
    # Vertical gardens
    if building.type in ["residential", "commercial"]:
        if rng.random() < 0.15:
            details.append({
                "type": "vertical_garden",
                "facade": rng.choice(["north", "south", "east", "west"]),
                "coverage": rng.uniform(0.2, 0.5)
            })
    
    # Landing pad (tall buildings)
    if building.height > 40:  # >10 floors
        if rng.random() < 0.2:
            details.append({
                "type": "landing_pad",
                "location": "roof",
                "size": rng.uniform(10, 20)
            })
    
    # Balconies (residential)
    if building.type == "residential" and rng.random() < 0.4:
        balcony_count = int(building.width / 5)  # ~5m per balcony
        for i in range(balcony_count):
            details.append({
                "type": "balcony",
                "floor": rng.randint(2, building.floor_count),
                "position": i * 5,
                "size": rng.uniform(3, 5)
            })
    
    return details
```

## Window Lighting System

**Status**: ðŸ“‹ **PLANNED** (Phase 2)

### Lighting Algorithm

**Decision**: Windows light and dim at appropriate times. Fake lighting acceptable (no dynamic shadows).

**Lighting States:**

1. **Daytime (Sun-facing)**
   - Bright (0.8-1.0 brightness)
   - Slight reflection
   - Interior visible (if high detail)

2. **Daytime (Shadow)**
   - Dimmer (0.4-0.6 brightness)
   - More interior visible
   - Some lights on

3. **Evening/Dawn**
   - Transition period
   - Mix of natural and artificial light
   - Gradual brightness change

4. **Nighttime**
   - Interior lights on (if occupied)
   - Brightness: 0.6-0.9 (artificial light)
   - Exterior dark
   - Silhouettes visible

**Lighting Calculation:**

```python
def calculate_window_lighting(window, building, time_of_day, sun_position):
    """Calculate window brightness and lighting state."""
    # Determine if window faces sun
    window_direction = get_window_direction(window, building)
    sun_direction = get_sun_direction(sun_position, building.position)
    
    faces_sun = dot_product(window_direction, sun_direction) > 0.5
    
    # Base brightness from time of day
    if 6 <= time_of_day < 18:  # Daytime
        if faces_sun:
            brightness = 0.9
            light_state = "day_bright"
        else:
            brightness = 0.5
            light_state = "day_shadow"
    elif 18 <= time_of_day < 20 or 5 <= time_of_day < 6:  # Dawn/Dusk
        brightness = 0.6
        light_state = "transition"
    else:  # Nighttime
        # Check if window is occupied
        if window.is_occupied:
            brightness = rng.uniform(0.6, 0.9)
            light_state = "night_lit"
        else:
            brightness = 0.1
            light_state = "night_dark"
    
    return {
        "brightness": brightness,
        "light_state": light_state,
        "color": get_light_color(light_state, time_of_day)
    }
```

**Occupancy Determination:**

```python
def determine_window_occupancy(window, window_seed, time_of_day):
    """Determine if window shows occupied (lights on)."""
    rng = seeded_random(window_seed)
    
    # Base occupancy probability
    if building.type == "residential":
        base_probability = 0.4  # 40% of residential windows occupied
    elif building.type == "commercial":
        # Commercial: high during day, low at night
        if 9 <= time_of_day < 17:
            base_probability = 0.7
        else:
            base_probability = 0.2
    else:
        base_probability = 0.3
    
    # Add variation
    window_occupancy = rng.random() < base_probability
    
    return window_occupancy
```

**Gradual Dimming:**

- Don't instantly switch lighting
- Interpolate brightness over 5-10 minutes (game time)
- Smooth transitions between states
- Store target brightness, interpolate current brightness

## Window Silhouettes

**Status**: ðŸ“‹ **PLANNED** (Phase 2)

**Decision**: Very simple silhouettes, sprites better than 3D models.

**Silhouette Types:**

1. **Simple 2D Sprites**
   - Basic human shapes
   - 3-5 different poses
   - Side-view silhouettes
   - No animation needed (static sprites)

2. **Occasional Movement**
   - Silhouettes change position every 30-60 seconds
   - Simple position updates (left, center, right)
   - No complex animations

**Implementation:**

```python
def generate_window_silhouette(window, window_seed, light_state):
    """Generate silhouette for lit window."""
    if light_state not in ["night_lit", "day_shadow"]:
        return None  # No silhouette if window not lit
    
    if not window.is_occupied:
        return None  # No silhouette if not occupied
    
    rng = seeded_random(window_seed)
    
    # Select silhouette type
    silhouette_type = rng.choice([
        "person_standing",
        "person_sitting",
        "person_walking"
    ])
    
    # Position within window
    position_x = rng.uniform(0.2, 0.8)  # 20-80% across window
    position_y = rng.uniform(0.3, 0.9)  # 30-90% up window
    
    return {
        "type": silhouette_type,
        "sprite_id": f"silhouette_{silhouette_type}",
        "position": (position_x, position_y),
        "scale": rng.uniform(0.8, 1.2),
        "update_interval": rng.randint(30, 60)  # Seconds
    }
```

**Performance Considerations:**

- Only generate silhouettes for lit, occupied windows
- Limit visible silhouettes (LOD: only close buildings)
- Use sprite atlas (all silhouettes in one texture)
- Batch render silhouettes
- Update positions infrequently (every 30-60 seconds)

**Sprite Assets:**

- 3-5 different silhouette sprites
- Simple black shapes on transparent background
- Side-view only (no front/back needed)
- Size: 64Ã—64 or 128Ã—128 pixels

## Park and Agricultural Areas

**Status**: ðŸ“‹ **PLANNED** (Phase 2)

### Parks

**Terrain Generation:**

```python
def generate_park_terrain(cell, cell_seed):
    """Generate park terrain with gentle undulation."""
    rng = seeded_random(cell_seed)
    
    # Use Perlin noise for terrain height
    heightmap = generate_heightmap(
        width=50, height=50,
        scale=10,  # Smooth variation
        seed=cell_seed
    )
    
    # Normalize height (keep variation small, 0-2m)
    heightmap = normalize_heightmap(heightmap, min_height=0, max_height=2)
    
    return heightmap
```

**Park Elements:**

1. **Paths**
   - Winding paths through park
   - 2-3m wide
   - Connect entrances
   - Use A* or similar for pathfinding

2. **Trees**
   - Spaced using Poisson disk sampling
   - 5-10m spacing
   - Vary tree types
   - 10-20 trees per park cell

3. **Structures**
   - Benches (along paths)
   - Playground equipment (if residential area)
   - Decorative sculptures
   - Small pavilions

4. **Dirt/Grass**
   - Dirt visible in paths
   - Grass texture for open areas
   - Procedural texture based on noise

### Agricultural Spin-Grav Segments

**Layout:**

```python
def generate_agricultural_segment(cell, cell_seed, segment_type):
    """Generate agricultural area."""
    rng = seeded_random(cell_seed)
    
    # Determine layout
    if segment_type == "terraced":
        # Terraced farming (sloped areas)
        terraces = generate_terraces(cell, rng)
    else:
        # Flat farming
        plots = generate_farming_plots(cell, rng)
    
    # Add infrastructure
    infrastructure = {
        "irrigation": generate_irrigation_system(cell, rng),
        "storage": generate_storage_buildings(cell, rng),
        "paths": generate_access_paths(cell, rng)
    }
    
    return {
        "plots": plots or terraces,
        "infrastructure": infrastructure,
        "crop_types": assign_crop_types(plots, rng)
    }
```

**Agricultural Elements:**

1. **Growing Plots**
   - Grid of growing areas
   - 5m Ã— 5m plots
   - Dirt visible
   - Crop types vary

2. **Infrastructure**
   - Irrigation systems
   - Storage buildings
   - Processing facilities
   - Access roads

3. **Dirt/Soil**
   - Visible soil in plots
   - Paths between plots
   - Terraced areas show soil layers

## Decorative Elements

**Status**: ðŸ“‹ **PLANNED** (Phase 2)

**Types:**

1. **Street Furniture**
   - Benches (along paths, in parks)
   - Street lights (along roads)
   - Trash bins (near buildings)
   - Signage (directional, informational)

2. **Plants**
   - Potted plants (near buildings)
   - Small trees (along streets)
   - Decorative shrubs
   - Vertical garden elements

3. **Art and Decorations**
   - Sculptures (parks, plazas)
   - Murals (building walls)
   - Holographic displays
   - Decorative lighting

**Placement Algorithm:**

```python
def place_decorative_elements(cells, chunk_seed):
    """Place decorative elements throughout chunk."""
    rng = seeded_random(chunk_seed)
    decorations = []
    
    for cell in cells:
        # Determine decoration density based on cell type
        if cell.type == "park":
            density = 0.3  # High density in parks
        elif cell.type == "plaza":
            density = 0.2
        elif cell.type == "road":
            density = 0.1
        else:
            density = 0.05
        
        # Place decorations
        decoration_count = int(cell.area * density / 100)  # Per 100mÂ²
        
        for i in range(decoration_count):
            decoration = {
                "type": select_decoration_type(cell.type, rng),
                "position": random_position_in_cell(cell, rng),
                "rotation": rng.uniform(0, 360),
                "scale": rng.uniform(0.8, 1.2)
            }
            decorations.append(decoration)
    
    return decorations
```

## Performance Optimization

**Status**: ðŸ“‹ **PLANNED** (Phase 2)

### LOD (Level of Detail) System

**Three LOD Levels:**

1. **Low LOD** (Far away, >500m)
   - Simple box shapes
   - No windows
   - No lighting
   - No silhouettes
   - Minimal polygons

2. **Medium LOD** (Mid distance, 100-500m)
   - Building shapes
   - Basic window grid (texture, not individual)
   - Simple lighting (per-building, not per-window)
   - No silhouettes

3. **High LOD** (Close, <100m)
   - Full building detail
   - Individual windows
   - Per-window lighting
   - Silhouettes (if high detail)

**LOD Selection:**

```python
def get_lod_level(distance, building_complexity):
    """Determine LOD level based on distance and complexity."""
    if distance > 500:
        return "low"
    elif distance > 100:
        return "medium"
    else:
        # Use building complexity for close buildings
        if building_complexity == "high_detail":
            return "high"
        elif building_complexity == "standard_detail":
            return "medium"
        else:
            return "low"
```

### Caching Strategy

**Generation Cache:**

```python
# Generate once, store in database
def generate_chunk(chunk_id, chunk_seed):
    """Generate chunk and store in database."""
    # Check if already generated
    if chunk_exists_in_db(chunk_id):
        return load_chunk_from_db(chunk_id)
    
    # Generate new chunk
    chunk_data = {
        "grid": generate_city_grid(...),
        "buildings": generate_buildings(...),
        "parks": generate_parks(...),
        "decorations": generate_decorations(...)
    }
    
    # Store in database
    save_chunk_to_db(chunk_id, chunk_data)
    
    return chunk_data
```

**Memory Cache:**

- Cache frequently accessed chunks in memory
- LRU eviction policy
- Cache size: 100-200 chunks
- Invalidate on modification

### Incremental Generation

**Priority System:**

1. **High Priority**: Visible chunks, player's current chunk
2. **Medium Priority**: Adjacent chunks, predicted movement path
3. **Low Priority**: Background chunks, far-away chunks

**Generation Queue:**

```python
class GenerationQueue:
    def __init__(self):
        self.high_priority = []
        self.medium_priority = []
        self.low_priority = []
    
    def add_chunk(self, chunk_id, priority):
        if priority == "high":
            self.high_priority.append(chunk_id)
        elif priority == "medium":
            self.medium_priority.append(chunk_id)
        else:
            self.low_priority.append(chunk_id)
    
    def get_next_chunk(self):
        if self.high_priority:
            return self.high_priority.pop(0)
        elif self.medium_priority:
            return self.medium_priority.pop(0)
        else:
            return self.low_priority.pop(0)
```

### Parallel Generation

**Python Service:**

- Use multiprocessing for CPU-bound generation
- Process multiple chunks simultaneously
- Queue system for generation requests
- Scale based on server capacity

```python
from multiprocessing import Pool

def generate_chunks_parallel(chunk_ids, chunk_seeds):
    """Generate multiple chunks in parallel."""
    with Pool(processes=4) as pool:
        results = pool.starmap(generate_chunk, zip(chunk_ids, chunk_seeds))
    return results
```

## Integration with Player Actions

**Status**: ðŸ“‹ **PLANNED** (Phase 2)

### Player Structure Override

**Rule**: Player-placed structures override procedural generation.

```python
def generate_building_cell(cell, player_structures):
    """Generate building, respecting player structures."""
    # Check if player has placed structure here
    player_structure = find_player_structure_at(cell.position, player_structures)
    
    if player_structure:
        # Use player structure, don't generate
        return {
            "type": "player_structure",
            "structure_id": player_structure.id,
            "geometry": player_structure.geometry
        }
    else:
        # Generate procedurally
        return generate_procedural_building(cell)
```

### Zone Adaptation

**Procedural generation adapts to player zones:**

```python
def generate_for_zone(zone, chunk_seed):
    """Generate content for player-defined zone."""
    # Use zone type to determine generation parameters
    if zone.type == "residential":
        building_types = ["apartment", "residential_block"]
        density = zone.importance * 0.7
    elif zone.type == "commercial":
        building_types = ["office", "shopping"]
        density = zone.importance * 0.8
    # ... etc
    
    # Generate with zone-specific parameters
    return generate_buildings(zone, building_types, density, chunk_seed)
```

### Regeneration on Zone Change

**When zones change:**

1. Mark affected chunks as "needs_regeneration"
2. Regenerate only if no player structures present
3. Preserve player structures
4. Regenerate surrounding areas for continuity

## Regeneration Strategy

**Status**: ðŸ“‹ **PLANNED** (Phase 2)

**Decision**: Follow recommendations - regenerate on demand, cache results, only regenerate when necessary.

### When to Regenerate

1. **Initial Generation**: When chunk first requested
2. **Zone Changes**: When zone boundaries/types change
3. **Seed Changes**: If world seed changes (rare)
4. **Player Request**: If player requests regeneration (admin feature)

### When NOT to Regenerate

1. **Player Structures Present**: Don't regenerate areas with player structures
2. **Recently Generated**: If generated within last hour (unless forced)
3. **Unchanged Zones**: If zone hasn't changed, use cached version

### Regeneration Process

```python
def regenerate_chunk(chunk_id, reason, force=False):
    """Regenerate chunk if needed."""
    # Check if regeneration needed
    if not force:
        if not should_regenerate(chunk_id, reason):
            return load_chunk_from_db(chunk_id)
    
    # Check for player structures
    player_structures = get_player_structures_in_chunk(chunk_id)
    if player_structures and not force:
        # Don't regenerate, preserve player structures
        return load_chunk_from_db(chunk_id)
    
    # Regenerate
    chunk_seed = get_chunk_seed(chunk_id)
    new_chunk = generate_chunk(chunk_id, chunk_seed)
    
    # Preserve player structures
    new_chunk = integrate_player_structures(new_chunk, player_structures)
    
    # Update database
    update_chunk_in_db(chunk_id, new_chunk)
    
    return new_chunk
```

### Caching Strategy

**Database Cache:**
- Store generated chunks in database
- Only regenerate if needed
- Version chunks (track changes)

**Memory Cache:**
- Cache frequently accessed chunks
- LRU eviction
- Invalidate on modification

**Client Cache:**
- Clients cache received chunks
- Check version on load
- Request updates if version changed

## Implementation Phases

### Phase 1: Service Foundation âœ… COMPLETE

**Goals:**
- Python service structure (FastAPI)
- Seed generation utilities
- Basic chunk generation endpoint (empty chunks)
- Go client for service communication
- Health check and debugging endpoints

**Deliverables:**
- âœ… Python service runs and responds to requests
- âœ… Seed generation utilities working (deterministic)
- âœ… Chunk generation endpoint returns chunks with ring floor geometry and station flares
- âœ… Ring floor geometry visible in client (gray rectangular planes with variable width from station flares)
- âœ… Go server can communicate with Python service
- âœ… Health check endpoint working
- âœ… Service configuration and environment variables
- âœ… Windows compatibility (default uses 127.0.0.1 instead of localhost)
- âœ… Chunk storage and database persistence implemented (PostGIS geometry storage)
- âœ… Station flare calculations implemented (variable-width and variable-height chunks)
- âœ… Per-chunk restricted zone generation implemented (one default restricted zone per chunk)

**Status**: âœ… **COMPLETE** - Service foundation implemented with basic geometry generation, station flares, and database persistence.

### Phase 2: MVP (Basic Generation) âœ… **COMPLETE**

**Goals:**
- Simple grid-based city generation
- Basic building shapes (rectangles)
- Building variability (subtypes, varied footprints, discrete heights)
- Simple window patterns with density variation by subtype
- Basic lighting (on/off based on time) - â³ **PENDING**
- Park generation (basic) - â³ **PENDING**
- Seed-based deterministic generation

**Deliverables:**
- âœ… City grid generation working
- âœ… Buildings generate in zones
- âœ… Building subtypes implemented (warehouse, factory, residence, agri_industrial, retail, mixed_use, apartment, campus, house, barn, park_structure)
- âœ… Enhanced building shape weights and characteristics (Geometry Version 7):
  - **Industrial Buildings**:
    - Mostly short (5-12m), wide (40-80m), and long (40-80m) buildings
    - Fewer windows (10-20% density depending on subtype)
    - Multiple side-by-side garage doors: warehouses have 2-4 garage doors (85% chance), factories have 1-3 garage doors (60% chance)
    - Garage doors placed side-by-side on the same facade with proper spacing
  - **Commercial Buildings**:
    - All buildings are 5-story office towers (exactly 20m tall, 5 floors of 4m each)
    - Mostly floor-to-ceiling windows (85% chance for full-height windows per floor)
    - Doors on all four sides (main door on r=0 facade, secondary doors on other three sides)
    - Office tower aesthetic with large glass facades
  - **Residential Buildings**:
    - Mix of two categories:
      - **Apartment/Campus buildings** (60%): Larger footprints (20-40m), taller (12-20m, 3-5 stories), multiple doors (2-3 additional)
      - **Houses** (40%): Smaller footprints (10-18m), shorter (8-12m, 2-3 stories), fewer doors (main door, 20% chance for one secondary)
    - Mostly standard windows (85% chance for standard windows per floor)
    - Windows on all four facades
  - **Agricultural Buildings**:
    - **Clustering system**: Buildings within 100m radius are grouped into clusters
    - Each cluster contains: 1 house (farmhouse), 1 barn (small warehouse), and 1-2 small industrial buildings
    - Clusters form organic farming communities
    - Individual building types: houses (10-18m footprint, 8-12m tall), barns (12-25m footprint, 5-10m tall), small industrial (15-30m footprint, 5-10m tall)
    - **All agricultural zones** generate agricultural structures: clustered buildings get assigned types within clusters, isolated buildings get randomly assigned (40% house, 30% barn, 30% small industrial)
  - **Park Buildings**:
    - Small scattered structures (5-15m footprint)
    - Mostly 1-2 stories (4-8m tall)
    - Sparse distribution throughout park zones
- âœ… Varied building footprints (5-80m width/depth depending on type and subtype)
- âœ… Discrete building heights (4m, 5m, 8m, 10m, 12m, 15m, 16m, or 20m - 1 to 5 floors of 4m each, with some intermediate heights for industrial)
- âœ… Windows generate on all four facades with density and type preferences varying by subtype
- âœ… New window system with full-height, standard, and ceiling windows (4m floor height)
- âœ… Door generation:
  - Main door always on facade facing r=0
  - Standard doors: 90cm wide Ã— 210cm tall
  - Commercial buildings have doors on all four sides
  - Apartment/campus buildings have multiple doors (2-3 additional)
  - Houses have fewer doors (main door, 20% chance for one secondary)
  - Industrial buildings REQUIRE at least 1 standard door on BOTH north and south sides
- âœ… Garage door generation with side-by-side placement:
  - Warehouses: REQUIRE at least 1 garage door on BOTH front and back facades, often 2-4 garage doors side-by-side
  - Factories: REQUIRE at least 1 garage door on BOTH front and back facades, 1-3 garage doors
  - Barns and agri-industrial: 70% chance, 1-2 garage doors
  - Utility doors: Each garage door has a utility door (90cm Ã— 210cm) placed immediately beside it
- âœ… Hub-specific color palettes for building rendering
  - 12 pillar hubs each with unique color schemes for 5 zone types
  - Color components: foundation, walls, roofs, windows_doors, trim
  - Colors stored in building properties and passed to client
  - Shader uniforms apply colors procedurally (no separate geometry for details)
  - API endpoint for clients to fetch color palettes
  - Automatic hub name lookup based on chunk position
  - Zone type normalization (handles mixed-use variations)
- âœ… Shader-based rendering for windows, doors, foundations, and trim
- âœ… Performance optimizations (material caching, geometry reuse, instanced rendering)
- â³ Basic lighting system (pending)
- â³ Parks generate with terrain (pending)
- âœ… All generation is deterministic
- âœ… Building boundary validation (three-method validation: rectangle containment, corner check, buffer check)
- âœ… Building spacing rules (can touch, or minimum 5m gap for alleys/streets)
- âœ… Structure persistence with chunks (including color information)

## Testing

**Status**: âœ… **COMPREHENSIVE TEST COVERAGE**

The procedural generation system has extensive test coverage for building generation, window/door placement, and zone-specific characteristics.

**Test Files:**
- `server/internal/procedural/tests/test_buildings.py` - Building generation tests (35 tests)
- `server/internal/procedural/tests/test_generation.py` - Chunk and structure generation tests (11 tests)
- **Total**: 46 tests collected

**Test Coverage Summary:**
- âœ… **Building Generation**: Seed generation, subtype distribution, dimensions, heights by zone type
- âœ… **Window System**: Generation on all four facades, density by subtype, type preferences (full-height, standard, ceiling)
- âœ… **Door System**: Main door placement (r=0 facing), secondary doors by building type, doors on all sides for commercial, overlap prevention
- âœ… **Garage Doors**: Side-by-side placement, multiple doors, placement by building subtype
- âœ… **Zone-Specific Tests**:
  - Commercial: 5-story validation, doors on all sides, full-height windows
  - Residential: Apartment/house differentiation, door counts, standard windows
  - Industrial: Few windows, garage door side-by-side placement
  - Agricultural: Clustering system, building type distribution
  - Park: Small size validation
- âœ… **Validation**: Building boundary validation, spacing rules, corner trim respect
- âœ… **Integration**: Structure format, persistence, color palette application, mixed-use variety

**Test Results**: 44 tests passing, 1 failed (door overlap test with tolerance for edge cases when commercial buildings have doors on all sides), 1 skipped

## Recent Changes and Bug Fixes

### Agricultural Zone Structure Generation
- âœ… **Fixed**: Agricultural zones along ring segments now properly generate agricultural structures (houses, barns, small industrial warehouses)
- âœ… **Improved**: All building cells in agricultural zones receive agricultural building types, not just clustered ones
- âœ… **Enhanced**: Isolated buildings (not in clusters) are randomly assigned: 40% house, 30% barn, 30% small industrial (warehouse)
- âœ… **Fixed**: Added missing `_get_building_dimensions_with_subtype()` function that was preventing agricultural structures from generating

### Door and Garage Door Persistence
- âœ… **Fixed**: Doors and garage doors now persist correctly after browser refresh
- âœ… **Enhanced**: Doors and garage_doors are saved to `model_data` when structures are stored in the database
- âœ… **Fixed**: WebSocket chunk data handler now extracts doors and garage_doors from `model_data` when serving chunk data from database
- âœ… **Enhanced**: Client-side extraction of doors from `model_data` happens at multiple levels:
  - During chunk structure extraction (`chunk-manager.js`)
  - During structure upsert to game state (`game-state.js`)
  - During building creation (`structure-manager.js`)
- âœ… **Result**: Doors persist correctly whether structures come from fresh chunk generation or from database-loaded chunks

### Door and Garage Door Specifications
- âœ… **Updated**: Standard door dimensions changed to 90cm wide Ã— 210cm tall (0.9m Ã— 2.1m)
- âœ… **Enhanced**: Industrial buildings (warehouses, factories) now REQUIRE at least 1 standard door on BOTH north and south sides (front and back facades)
- âœ… **Enhanced**: Utility doors (90cm Ã— 210cm) are automatically placed beside each garage door (30cm spacing), either to the right or left depending on available space
- âœ… **Improved**: Garage door requirements: Warehouses and factories REQUIRE at least 1 garage door on BOTH front and back facades

### Building Details
- âœ… **Enhanced**: Corner trim width is now variable between 10cm and 50cm per building (randomly generated per building)
- âœ… **Improved**: Window opacity increased to 65% with slight reflectivity (1.2x brightness multiplier) for more realistic glass appearance
- âœ… **Fixed**: Foundations now properly extend from ground level (0) - walls render from ground to total height (foundation + building)
- âœ… **Fixed**: Door vertical positioning - all doors (standard, garage, truck bay, utility) now start at the top of foundations instead of overlapping them
- âœ… **Enhanced**: Truck bay door type preservation - door type (`garage`, `truck_bay`) is preserved when extracting door information for facade rendering
- âœ… **Enhanced**: Wall height calculations - `totalWallHeight` now correctly includes foundation height (foundation + building height) for proper positioning

### Grid Overlay
- âœ… **Updated**: Minor grid lines changed from white (0xffffff) back to medium gray (0x9c9c9c) to reduce visual contrast
- âœ… **Maintained**: Major grid lines remain red (horizontal) and blue (vertical) at 5m intervals, with white (now gray) 1m minor grid inside

### Building Boundary Validation
- âœ… **Improved**: Buffer margin for building boundary validation reduced from 50cm to 10cm to allow buildings in narrower zones
- âœ… **Enhanced**: Buffer check only applies to zones larger than 100 mÂ² (narrower zones like agricultural zones can place buildings closer to edges)

### Phase 3: Enhancement

**Goals:**
- More building variety (L-shapes, combinations)
- Window lighting with dimming
- Silhouettes in windows
- More decorative elements
- Cultural style variation
- Building complexity levels

**Deliverables:**
- Complex building shapes
- Dynamic window lighting
- Silhouette system working
- Cultural styles applied
- Adaptive complexity based on traffic/attention

### Phase 4: Polish

**Goals:**
- Advanced architectural details
- Complex building shapes
- Sophisticated city layouts
- Performance optimization
- Advanced lighting effects

**Deliverables:**
- Full detail buildings
- Optimized generation performance
- Advanced lighting and effects
- Production-ready system

## Open Questions

1. How detailed should building interiors be? (Currently exterior only)
2. Should we support custom building templates from players?
3. How to handle building destruction/decay over time?
4. Should agricultural areas have visible crops growing?
5. How to balance generation time vs. detail level?

## Future Considerations

- **Building Interiors**: Generate interior layouts for enterable buildings
- **Dynamic Building Growth**: Buildings evolve over time based on zone development
- **Weather Effects**: Buildings adapt to weather (snow, rain, etc.)
- **Advanced Lighting**: Ray-traced lighting for high-end clients
- **Procedural Textures**: Generate building materials procedurally
- **AI-Generated Architecture**: Use ML for more varied building designs
- **Player Customization**: Allow players to customize building styles in their zones
- **Historical Buildings**: Generate buildings that reflect historical Earth architecture
- **Adaptive Density**: Building density adapts to player activity over time

