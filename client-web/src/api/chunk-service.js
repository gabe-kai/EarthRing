/**
 * Chunk API Service
 * Handles chunk-related API calls
 */

import { getAPIURL } from '../config.js';
import { getAccessToken, ensureValidToken } from '../auth/auth-service.js';

/**
 * Get chunk metadata
 * @param {string} chunkID - Format: "floor_chunk_index" (e.g., "0_12345")
 */
export async function getChunkMetadata(chunkID) {
  const token = getAccessToken();
  if (!token) {
    throw new Error('Not authenticated');
  }

  const response = await fetch(getAPIURL(`/api/chunks/${chunkID}`), {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
  });

  if (!response.ok) {
    let errorMessage = 'Failed to fetch chunk metadata';
    try {
      const error = await response.json();
      // Server returns { "error": "...", "message": "..." } or { "code": "...", "message": "..." }
      errorMessage = error.message || error.error || errorMessage;
      // If it's an authentication error, try to refresh and retry
      if (response.status === 401 || error.code === 'InvalidToken' || error.code === 'MissingToken') {
        const refreshed = await ensureValidToken();
        if (!refreshed) {
          // ensureValidToken already handled logout and redirect
          throw new Error('Session expired');
        }
        // Retry the request with new token
        const newToken = getAccessToken();
        const retryResponse = await fetch(getAPIURL(`/api/chunks/${chunkID}`), {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${newToken}`,
            'Content-Type': 'application/json',
          },
        });
        if (!retryResponse.ok) {
          throw new Error('Session expired');
        }
        return await retryResponse.json();
      }
    } catch (e) {
      errorMessage = `HTTP ${response.status}: ${response.statusText}`;
    }
    throw new Error(errorMessage);
  }

  return await response.json();
}

/**
 * Delete a chunk from the database
 * This will cause the procedural service to regenerate the chunk on next request.
 * @param {string} chunkID - Format: "floor_chunk_index" (e.g., "0_12345")
 * @returns {Promise<Object>} Success response with message
 */
export async function deleteChunk(chunkID) {
  const token = getAccessToken();
  if (!token) {
    throw new Error('Not authenticated');
  }

  const response = await fetch(getAPIURL(`/api/chunks/${chunkID}`), {
    method: 'DELETE',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
  });

  if (!response.ok) {
    let errorMessage = 'Failed to delete chunk';
    try {
      const error = await response.json();
      errorMessage = error.message || error.error || errorMessage;
      if (response.status === 401 || error.code === 'InvalidToken' || error.code === 'MissingToken') {
        errorMessage = 'Session expired. Please log in again.';
      } else if (response.status === 404) {
        errorMessage = error.message || 'Chunk not found';
      }
    } catch (e) {
      errorMessage = `HTTP ${response.status}: ${response.statusText}`;
    }
    throw new Error(errorMessage);
  }

  return await response.json();
}

/**
 * Delete all chunks from the database
 * WARNING: This is a destructive operation that cannot be undone
 * All chunks will be regenerated by the procedural service on next request
 * @returns {Promise<Object>} Success response with deleted count
 */
export async function deleteAllChunks() {
  const token = getAccessToken();
  if (!token) {
    throw new Error('Not authenticated');
  }

  const response = await fetch(getAPIURL('/api/admin/chunks/reset'), {
    method: 'DELETE',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
  });

  if (!response.ok) {
    let errorMessage = 'Failed to delete all chunks';
    try {
      const error = await response.json();
      errorMessage = error.message || error.error || errorMessage;
      if (response.status === 401 || error.code === 'InvalidToken' || error.code === 'MissingToken') {
        errorMessage = 'Session expired. Please log in again.';
      }
    } catch (e) {
      errorMessage = `HTTP ${response.status}: ${response.statusText}`;
    }
    throw new Error(errorMessage);
  }

  return await response.json();
}

